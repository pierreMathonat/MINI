package com.engine.core;	import nme.display.Bitmap;	import nme.display.BitmapData;	import com.engine.utils.Side;	import haxe.xml.Fast;		class BSprite extends Graphic	{				private var dirty:Bool;				// looking & Side.LEFT 		private var	_facing:Int;				//animation				private var	_anims:Array<Anim>;		private var _default:Anim;		private var	_anim:Anim;		private var	_frame:Int;				public var anim(getAnim, setAnim):String;		public var frame(getFrame, setFrame):Int;		public var facing(getFacing, setFacing):Int;		public function new(?tileset:BitmapData = null, ?anims:String ="", ?flipped:Bool = false) {			super();			_default = (new Anim("Default"));			if (tileset != null) 				loadGraphic(tileset, flipped);			if (anims != "")				loadAnims (anims);		}						// INIT ANIMS				public function loadAnims(?a:String = ""):Void {				_anims = new Array<Anim>();				var c:Fast = new Fast(Xml.parse(a));				var source:Fast = c.node.tilesheet;							for (node in source.nodes.anim) {					var id = node.att.id;					var len = Std.parseInt(node.att.length);					var delay = Std.parseInt(node.att.delay);					var row = Std.parseInt(node.att.row);					var loop = Std.parseInt(node.att.loop);						_anims.push(new Anim(id, len, row, delay, loop));				}							resize(Std.parseInt(source.att.tileW), Std.parseInt(source.att.tileH));						updateBatch();		}				public function setAnim(name:String):String {			if (_anims == null) return "";			if (_anim != null && name == _anim.name) return name;			for (a in 0..._anims.length) {				if (_anims[a].name == name) {					_anim = _anims[a];					_frame = 0;					return name;				}			}			return "";		}				override public function update():Void {			if(_anim==null)_anim=_default;			if(_anim.length>1)nextFrame();		}				public function nextFrame():Void{			if((Engine.time-_anim.lastFrameTime)>_anim.delay){				_anim.lastFrameTime=Engine.time;				_frame++;				if (_frame > _anim.length - 1)					if (_anim.loop==1)_frame = 0 					else {_frame = _anim.length - 1;}				dirty=true;			}		}				public function calcFrame():Void {			var col:Int = _Tcolumns;			var i:Int = _frame;						if (_flipped) col *= 2;			if (_facing & Side.LEFT > 0) i = col - _frame -1;						Id = tiles[_anim.row * col + i];			dirty=false;		}				override public function render():Void { 			if (dirty) calcFrame();			batch.add(_point, Id);		}				public function getAnim():String { return _anim.name; }		public function getFrame():Int { return _frame; }		public function setFrame(v:Int):Int { return _frame = v; }		public function setFacing(v:Int):Int { _facing = v; dirty = true; return _facing; }		public function getFacing():Int { return _facing; }		}