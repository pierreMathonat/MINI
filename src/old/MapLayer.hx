package com.engine.core;	import nme.geom.Point;	import nme.geom.Rectangle;	import nme.display.BitmapData;	import com.engine.utils.BMath;		//helper class for map layers rendering	class MapLayer extends Graphic {						private var _tileW:Int;		private var _tileH:Int; 				private var _name:String;		private var _parallax:Float;		private var _columns:Int;		private var _rows:Int;				private var _tileset:Tileset;				//private var _map:BitmapData;		private var _map:Array<Int>;				public var parallax(getParallax,setParallax):Float;				public function new(tileset:Tileset,columns:Int,rows:Int,name:String="layer",_visible:Bool=true,collide:Bool=false) {			// constructor code			super();			visible=_visible;			_columns=columns;			_rows=rows;						_tileset=tileset;			_tileW = _tileset.width;			_tileH = _tileset.height;						loadGraphic(tileset.pixels);			resize(_tileW, _tileH);			updateBatch();						//_map=new BitmapData(_columns,_rows,false,0);			_map = new Array<Int>();			_parallax=0;			_name=name;		}					override public function draw(x:Int,y:Int):Void {			render();		}				override public function render():Void{						var numRow:Int = BMath.ceil(Std.int(_cam.Height/_tileH));			var numCol:Int = BMath.ceil(Std.int(_cam.Width/_tileW));			var parallax = Std.int(_parallax *(_cam.scrollx));							var startRow = Std.int((_cam.scrolly)/_tileH);			var startCol = Std.int((_cam.scrollx+parallax)/_tileW);						//correction for per pixel scrolling			var xC = _cam.scrollx - (startCol)*_tileW;			var yC = _cam.scrolly - (startRow)*_tileH;						//draw each tile			for(row in 0...numRow){				var rowindex = startRow+row;				for(col in 0...numCol){					var colindex= startCol+col;					if (colindex >= _columns) { colindex -= Std.int(colindex / _columns) * _columns; }					//id =_map.getPixel(colindex,rowindex);					var id = _map[rowindex * _columns + colindex];					if(id>0){						_point.y = (row*_tileH)-yC;						_point.x = (col*_tileW)-xC-parallax;												batch.add(_point, tiles[id-1]);					}				}			}		}				public function fromArray(v:Array<Dynamic>):Void{			for (i in 0...v.length) {				_map[i] = Std.parseInt(v[i]);			}		}				public function setName(v:String):String{ return _name=v;}		public function setParallax(v:Float):Float{ return _parallax=v;}		public function setTileset(v:Tileset):Tileset{ return _tileset=v;}						public function getName():String{return _name;}		public function getParallax():Float{return _parallax;}		public function getTileset():Tileset{return _tileset;}	}